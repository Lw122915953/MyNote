# 一：

## 1、sql优化的原因

性能低、执行时间太长、等待时间太长、SQL语句欠佳（连接查询）、索引失效、服务器参数设置不佳

## 2、sql编写和解析过程

编写过程：select.. dinstinct ..from ..join ..on ..where ..group by ..having ..order by

解析过程：from ..on .. join ..where .. group by... having.. select dinstinct.. order by

## 3、索引（sql优化主要在于索引）

索引：相当于书的目录

索引：index是帮助MySQL高效获取数据的数据结构。索引是数据结构（数：B树（默认）、hash树）

索引的弊端：需要内存/空间（索引本身很大）

## 4、索引分类

单值索引：单列，	一个表可以有多个单值索引

唯一索引：不能重复

复合索引：多个列构成的索引（相当于二级目录）

## 5、DDL和DML

DDL不需要commit

DML需要commit

## 6、索引失效

[索引失效的7种情况](https://www.cnblogs.com/liehen2046/p/11052666.html)

### 1、什么时候没用

1.有or必全有索引;
2.复合索引未用左列字段;
3.like以%开头;
4.需要类型转换;
5.where中索引列有运算;
6.where中索引列使用了函数;
7.如果mysql觉得全表扫描更快时（数据少）;

### 2、什么时没必要用

1.唯一性差;
2.频繁更新的字段不用（更新索引消耗）;
3.where中不用的字段;
4.索引使用<>时，效果一般;

### 3、详述（转）

索引并不是时时都会生效的，比如以下几种情况，将导致索引失效：

- 如果条件中有or，即使其中有部分条件带索引也不会使用(这也是为什么尽量少用or的原因)，例子中user_id无索引

注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引

![img](https://img2018.cnblogs.com/blog/1623038/201906/1623038-20190619181118118-1784753048.png)

- 对于复合索引，如果不使用前列，后续列也将无法使用，类电话簿。
- like查询是以%开头

![img](https://img2018.cnblogs.com/blog/1623038/201906/1623038-20190619181236139-968114236.png)

- 存在索引列的数据类型隐形转换，则用不上索引，比如列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引

![img](https://img2018.cnblogs.com/blog/1623038/201906/1623038-20190619181326223-1654473887.png)

- where 子句里对索引列上有数学运算，用不上索引

![img](https://img2018.cnblogs.com/blog/1623038/201906/1623038-20190619181436583-1773123023.png)

- where 子句里对有索引列使用函数，用不上索引

![img](https://img2018.cnblogs.com/blog/1623038/201906/1623038-20190619181457265-1885631328.png)

- 如果mysql估计使用全表扫描要比使用索引快,则不使用索引

> 比如数据量极少的表

### 4、什么情况下不推荐使用索引？

1) 数据唯一性差（一个字段的取值只有几种时）的字段不要使用索引

> 比如性别，只有两种可能数据。意味着索引的二叉树级别少，多是平级。这样的二叉树查找无异于全表扫描。

2) 频繁更新的字段不要使用索引

> 比如logincount登录次数，频繁变化导致索引也频繁变化，增大数据库工作量，降低效率。

3) 字段不在where语句出现时不要添加索引,如果where后含IS NULL /IS NOT NULL/ like ‘%输入符%’等条件，不建议使用索引

> 只有在where语句出现，mysql才会去使用索引

4） where 子句里对索引列使用不等于（<>），使用索引效果一般

# 二：逻辑分层与存储引擎

## 1、逻辑分层

![1572071429226](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1572071429226.png)

## 2、存储引擎（默认InnoDB）

 ![1572071500969](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1572071500969.png)

# 三：sql索引

# 四：单表优化([点我百度](https://blog.csdn.net/yjn1995/article/details/98472759))

MySQL单表优化
单表优化概述
字段优化
索引优化
SQL语句优化
引擎优化
系统调优参数
升级硬件
单表优化概述
当MySQL单表记录数过大时，增删改查性能都会急剧下降，可以在以下几个方面进行优化
除非单表数据未来会一直不断上涨，否则不要一开始就考虑拆分，拆分会带来逻辑、部署、运维的各种复杂度，
一般以整型值为主的表在千万级以下，字符串为主的表在五百万以下是没有太大问题的。
而事实上很多时候MySQL单表的性能依然有不少优化空间，甚至能正常支撑千万级以上的数据量

字段优化
尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED
VARCHAR的长度只分配真正需要的空间
使用枚举或整数代替字符串类型
尽量使用TIMESTAMP而非DATETIME，
单表不要有太多字段，建议在20以内
避免使用NULL字段，很难查询优化且占用额外索引空间
用整型来存IP

索引优化
索引并不是越多越好，要根据查询有针对性的创建，考虑在WHERE和ORDER BY命令上涉及的列建立索引，可根据EXPLAIN来查看是否用了索引还是全表扫描
应尽量避免在WHERE子句中对字段进行NULL值判断，否则引擎将放弃使用索引而进行全表扫描
值分布很稀少的字段不适合建索引，例如"性别"这种只有两个值的字段
字符字段只建前缀索引
字符字段最好不要做主键
不用外键，由程序保证约束
尽量不用UNIQUE，由程序保证约束
使用多列索引时注意顺序和查询条件保持一致，同时删除不必要的单列索引

SQL语句优化
可通过开启慢查询日志来找出较慢的SQL
不做列运算：SELECT id WHERE age + 1 = 10，任何对列的操作都将导致全表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边
sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库
不用SELECT *
OR改写成IN：OR的效率是n级别，IN的效率是log(n)级别，in的个数建议控制在200以内
不用函数和触发器，在应用程序实现
避免%xxx式查询
少用JOIN
使用同类型进行比较，比如用’123’和’123’比，123和123比
尽量避免在WHERE子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描
对于连续数值，使用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5
列表数据不要拿全表，要使用LIMIT来分页，每页数量也不要太大

引擎优化
MyISAM适合SELECT密集型的表，而InnoDB适合INSERT和UPDATE密集型的表

系统调优参数
可以使用下面几个工具来做基准测试：
sysbench：一个模块化，跨平台以及多线程的性能测试工具
iibench-mysql：基于 Java 的 MySQL/Percona/MariaDB 索引进行插入性能测试工具
tpcc-mysql：Percona开发的TPC-C测试工具

具体的调优参数内容较多，具体可参考官方文档，这里介绍一些比较重要的参数：

back_log：指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。也就是说，如果MySQL的连接数据达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。

wait_timeout：数据库连接闲置时间，闲置连接会占用内存资源。可以从默认的8小时减到半小时

max_user_connection: 最大连接数，默认为0无上限，最好设一个合理上限

thread_concurrency：并发线程数，设为CPU核数的两倍

skip_name_resolve：禁止对外部连接进行DNS解析，消除DNS解析时间，但需要所有远程主机用IP访问

key_buffer_size：索引块的缓存大小，增加会提升索引处理速度，对MyISAM表性能影响最大。

innodb_buffer_pool_size：缓存数据块和索引块，对InnoDB表性能影响最大。

innodb_additional_mem_pool_size：InnoDB存储引擎用来存放数据字典信息以及一些内部数据结构的内存空间大小，当数据库对象非常多的时候，适当调整该参数的大小以确保所有数据都能存放在内存中提高访问效率，当过小的时候，MySQL会记录Warning信息到数据库的错误日志中，这时就需要该调整这个参数大小

innodb_log_buffer_size：InnoDB存储引擎的事务日志所使用的缓冲区，一般来说不建议超过32MB

query_cache_size：缓存MySQL中的ResultSet，也就是一条SQL语句执行的结果集，所以仅仅只能针对select语句。当某个表的数据有任何任何变化，都会导致所有引用了该表的select语句在Query Cache中的缓存数据失效。

read_buffer_size：MySql读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySql会为它分配一段内存缓冲区。如果对表的顺序扫描请求非常频繁，可以通过增加该变量值以及内存缓冲区大小提高其性能

sort_buffer_size：MySql执行排序使用的缓冲大小。如果想要增加ORDER BY的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。如果不能，可以尝试增加sort_buffer_size变量的大小

read_rnd_buffer_size：MySql的随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySql会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySql会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。

record_buffer：每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，可能想要增加该值

thread_cache_size：保存当前没有与连接关联但是准备为后面新的连接服务的线程，可以快速响应连接的线程请求而无需创建新的

table_cache：类似于thread_cache_size，但用来缓存表文件，对InnoDB效果不大，主要用于MyISAM

升级硬件
根据MySQL是CPU密集型还是I/O密集型，通过提升CPU和内存、使用SSD，都能显著提升MySQL性能

