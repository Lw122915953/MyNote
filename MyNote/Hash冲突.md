#  关于hash冲突的初步理解

2019-06-29 16:30:27  更多



版权声明：本文为博主原创文章，遵循[ CC 4.0 BY-SA ](http://creativecommons.org/licenses/by-sa/4.0/)版权协议，转载请附上原文出处链接和本声明。本文链接：https://blog.csdn.net/qq_41864321/article/details/93920730

# Hash冲突

## 什么是哈希冲突

> #### 理解哈希函数
>
> 关键字和它在表中存储位置之间存在一种函数关系。这个函数我们称为为哈希函数。
> hash:散列、杂凑
> 就是把任意长度的输入，通过散列算法，变成固定长度的输出，这种是一种压缩映射.

那么在这种情况下，不同的输入可能会产生相同的散列值，即这种状况下他们对应的哈希数的值是相同的，因为值相同所以不可能由散列值确定唯一的输入值，这种情况就是哈希冲突

**键(key)经过hash函数得到的结果作为地址去存放当前的键值对(key-value)(hashmap的存值方式)，但是却发现该地址已经有值了，就会产生冲突。这个冲突就是hash冲突了。**

换句话说就是：**如果两个不同对象的hashCode相同，这种现象称为hash冲突。**

## 解决哈希冲突

有以下的方式可以解决哈希冲突：

- 开放定址法
- 再哈希法
- 链地址法
- 建立公共溢出区

### 开放定址法

这种方法的意思是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。

- 线性探测再散列
  当发生冲突的时候，顺序的查看下一个单元
- 二次(平方)探测再散列
  当发生冲突的时候，在表的左右进行跳跃式探测
- 伪随机探测再散列
  建立一个伪随机数发生器，并给一个随机数作为起点

### 再hash法

这种方式是同时构造多个哈希函数，当产生冲突时，计算另一个哈希函数的值。
这种方法不易产生聚集，但增加了计算时间。

### 链地址法

将所有哈希地址相同的都链接在同一个链表中 ，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。
**hashmap就是用此方法解决冲突的。**

### 建立一个公共溢出区

将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。

## 优缺点

##### 开放散列（open hashing）/ 拉链法（针对桶链结构）

优点：

- 在总数频繁变动的时候可以节省开销，避免了动态调整；
- 记录存储在节点里，动态分布，避免了指针的开销
- 删除时候比较方便

缺点：

- 因为存储是动态的，所以在查询的时候跳转需要更多的时间的开销
- 在key-value可以预知，以及没有后续增改操作时候，封闭散列性能优于开放散列
- 不容易序列化

##### 封闭散列（closed hashing）/ 开放定址法

优点：

- 容易序列化
- 如果可以预知数据总数，可以创建完美哈希数列

缺点：

- 存储的记录数目不能超过桶组数，在交互时候会非常麻烦
- 使用探测序列，计算时间成本过高
- 删除的时候比较麻烦